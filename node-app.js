// Generated by CoffeeScript 1.3.3
var WorkQueue, events, file, http, io, queue, schedule, server, socket, socketio, ssh, static_,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

static_ = require("node-static");

http = require("http");

ssh = require("./ssh");

events = require("events");

file = new static_.Server("./web");

server = http.createServer(function(request, response) {
  return request.addListener("end", function() {
    return file.serve(request, response);
  });
});

server.listen(80);

socketio = require('socket.io');

io = socketio.listen(server);

socket = null;

WorkQueue = (function(_super) {

  __extends(WorkQueue, _super);

  function WorkQueue() {
    this.processing = false;
    this.queue;
  }

  WorkQueue.prototype.process = function(exp, cb) {
    var _this = this;
    return schedule(exp, function(result) {
      if (result) {
        cb(result);
      }
      _this.processing = false;
      return _this.next();
    });
  };

  WorkQueue.prototype.next = function() {
    var args;
    if ((!this.processing) && (this.queue.length !== 0)) {
      args = this.queue.shift();
      this.processing = true;
      return this.process.apply(this, args);
    }
  };

  WorkQueue.prototype.push = function(exp, cb) {
    this.queue.push([exp, cb]);
    return this.next(exp, cb);
  };

  WorkQueue.prototype.cancel = function(exp) {
    var idx, q, _i, _len, _ref;
    _ref = this.queue;
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      q = _ref[idx];
      if (q[0].id === exp.id) {
        q.splice(idx, 1);
        return;
      }
    }
    ssh.cancel();
    this.processing = false;
    return this.next();
  };

  return WorkQueue;

})(events.EventEmitter);

queue = new WorkQueue;

io.sockets.on("connection", function(_socket) {
  var chk;
  socket = _socket;
  setTimeout(chk = function() {
    return ssh.checkNodes(function(status) {
      socket.emit("status", status);
      return setTimeout(chk, 5000);
    });
  }, 5000);
  socket.on("cancel", function(data) {
    return queue.cancel(data);
  });
  socket.on("setup", function(data) {
    return ssh.setup();
  });
  return socket.on("schedule", function(data) {
    var exp;
    exp = JSON.parse(data);
    return queue.push(exp, function(result) {
      exp.status = "done";
      switch (exp.expType) {
        case "Throughput and Loss":
          exp.result = {
            loss: result.lost / result.total * 100,
            throughput: result.bandwidth_bps / 1000000
          };
          break;
        case "File Transfer":
          exp.result = {
            delay: result.time_s
          };
      }
      console.log(exp.result);
      return socket.emit("update", exp);
    });
  });
});

schedule = function(exp, cb) {
  var run;
  exp.status = "running";
  socket.emit("update", exp);
  run = function() {
    switch (exp.expType) {
      case "Throughput and Loss":
        return ssh.runIperf(cb);
      case "File Transfer":
        return ssh.runUFTP(cb);
    }
  };
  switch (exp.bsConf) {
    case "HARQ and ARQ":
      return ssh.config(1, 1, 0, run);
    case "HARQ only":
      return ssh.config(1, 0, 0, run);
    case "NC":
      return ssh.config(0, 0, 0, run);
  }
};
