// Generated by CoffeeScript 1.3.3
var events, file, his1, his2, http, io, schedule, server, socket, socketio, ssh, state, static_, upd;

static_ = require("node-static");

http = require('http');

events = require("events");

ssh = require("./ssh");

file = new static_.Server("./web");

server = http.createServer(function(request, response) {
  return file.serve(request, response);
});

server.listen(8081);

socketio = require('socket.io');

io = socketio.listen(server);

socket = null;

state = "idle";

his1 = "";

his2 = "";

ssh.consolestream.write = function(data) {
  his2 += data.toString();
  return true;
};

setTimeout(upd = function() {
  io.sockets.emit("state", {
    state: state,
    his1: his1,
    his2: his2
  });
  return setTimeout(upd, 1000);
}, 1000);

io.sockets.on("connection", function(_socket) {
  socket = _socket;
  socket.emit("state", state);
  socket.on("restartBS", function(data) {
    return ssh.restartBS();
  });
  socket.on("checkNodes", function(data) {
    return ssh.checkNodes(function(status) {
      return socket.emit("checkNodes", status);
    });
  });
  socket.on("checkOrbit", function(data) {
    return ssh.checkOrbit(function(canAccess) {
      return socket.emit("checkOrbit", canAccess);
    });
  });
  socket.on("cancel", function(data) {
    ssh.cancel();
    return socket.emit("cancel");
  });
  socket.on("setup", function(data) {
    if (state === "busy") {
      ssh.cancel();
      ssh.cancel();
      ssh.cancel();
    }
    his1 = "Setting up nodes 1 and 2. This operation takes up to 15 minuites.\n";
    his2 = "";
    state = "busy";
    return ssh.setup(function() {
      socket.emit("setup");
      return state = "idle";
    });
  });
  return socket.on("run", function(data) {
    var exp,
      _this = this;
    if (state === "busy") {
      exp.status = "error";
      socket.emit("update", exp);
      return;
    }
    state = "busy";
    exp = JSON.parse(data);
    return schedule(exp, function(result) {
      state = "idle";
      if (!result) {
        exp.status = "error";
        socket.emit("update", exp);
        return;
      }
      exp.status = "done";
      switch (exp.expType) {
        case "Throughput and Loss":
          exp.result = {
            loss: result.lost / result.total * 100,
            throughput: result.bandwidth_bps / 1000000
          };
          break;
        case "File Transfer":
          exp.result = {
            delay: result.time_s
          };
      }
      socket.emit("update", exp);
      return socket.emit("ready");
    });
  });
});

schedule = function(exp, cb) {
  var run, txt;
  txt = "\nRunning " + exp.expType + " experiment with " + exp.bsConf;
  if (exp.bsConf === "NC") {
    txt += "-" + exp.redundancy;
  }
  his1 = txt;
  his2 = "";
  exp.status = "running";
  socket.emit("update", exp);
  run = function() {
    switch (exp.expType) {
      case "Throughput and Loss":
        return ssh.runIperf(cb);
      case "File Transfer":
        return ssh.runUFTP(cb);
    }
  };
  switch (exp.bsConf) {
    case "HARQ and ARQ":
      return ssh.config(1, 1, 0, run);
    case "ARQ only":
      return ssh.config(0, 1, 0, run);
    case "HARQ only":
      return ssh.config(1, 0, 0, run);
    case "NC":
      return ssh.config(0, 0, 1, run);
    case "Raw":
      return ssh.config(0, 0, 0, run);
  }
};
